// solana-web3-wolf.min.js
// Minimal browser-only Solana web3 for Wolf Machine (no Buffer, no require)

(function(global){
  // --- BASE58 ---
  const ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
  function base58encode(buffer) {
    let digits = [0];
    for (let i = 0; i < buffer.length; ++i) {
      let carry = buffer[i];
      for (let j = 0; j < digits.length; ++j) {
        carry += digits[j] << 8;
        digits[j] = carry % 58;
        carry = (carry / 58) | 0;
      }
      while (carry) {
        digits.push(carry % 58);
        carry = (carry / 58) | 0;
      }
    }
    let str = '';
    for (let k = 0; buffer[k] === 0 && k < buffer.length - 1; ++k) str += ALPHABET[0];
    for (let q = digits.length - 1; q >= 0; --q) str += ALPHABET[digits[q]];
    return str;
  }

  // --- PublicKey ---
  function PublicKey(hex) {
    if (!(this instanceof PublicKey)) return new PublicKey(hex);
    if (hex instanceof Uint8Array) this._key = hex;
    else if (typeof hex === "string") this._key = base58decode(hex);
    else throw new Error("Invalid public key input");
    this.toString = () => base58encode(this._key);
    this.toBytes = () => this._key;
  }
  function base58decode(str) {
    let bytes = [0];
    for (let c of str) {
      let val = ALPHABET.indexOf(c);
      if (val < 0) continue;
      for (let j = 0; j < bytes.length; ++j) {
        val += bytes[j] * 58;
        bytes[j] = val & 0xff;
        val >>= 8;
      }
      while (val) {
        bytes.push(val & 0xff);
        val >>= 8;
      }
    }
    return new Uint8Array(bytes.reverse().slice(0, 32));
  }

  // --- clusterApiUrl ---
  function clusterApiUrl(network) {
    if (network === "devnet") return "https://api.devnet.solana.com";
    if (network === "testnet") return "https://api.testnet.solana.com";
    return "https://api.mainnet-beta.solana.com";
  }

  // --- Connection ---
  function Connection(endpoint) {
    this.endpoint = endpoint;
    this.getRecentBlockhash = async function() {
      const res = await fetch(this.endpoint, {
        method: "POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify({jsonrpc:"2.0",id:1,method:"getLatestBlockhash",params:[]})
      });
      const data = await res.json();
      return { blockhash: data.result.value.blockhash };
    };
    this.sendRawTransaction = async function(raw) {
      const b64 = btoa(String.fromCharCode.apply(null, raw));
      const res = await fetch(this.endpoint, {
        method: "POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify({jsonrpc:"2.0",id:1,method:"sendTransaction",params:[b64,{skipPreflight:true}]})
      });
      const data = await res.json();
      if (data.error) throw new Error(data.error.message);
      return data.result;
    };
    this.confirmTransaction = async function(sig) {
      // Simple poll for confirmation
      for (let i=0; i<15; ++i) {
        const res = await fetch(this.endpoint, {
          method: "POST",
          headers: {"Content-Type":"application/json"},
          body: JSON.stringify({jsonrpc:"2.0",id:1,method:"getConfirmedTransaction",params:[sig]})
        });
        const data = await res.json();
        if (data.result) return true;
        await new Promise(r=>setTimeout(r,500));
      }
      throw new Error("Confirmation timed out");
    };
  }

  // --- Transaction ---
  function Transaction() {
    this.instructions = [];
    this.add = (...ixs) => { this.instructions.push(...ixs); return this; };
    // Skipping real serialization here: you will use Phantom/Solflare's signTransaction.
    this.serialize = () => { throw new Error("Serialization only supported by wallet extension"); }
  }

  // --- SystemProgram ---
  const SystemProgram = {
    transfer({fromPubkey,toPubkey,lamports}) {
      // 4 = transfer, https://docs.solana.com/developing/programming-model/transactions
      let keys = [
        {pubkey:fromPubkey, isSigner:true, isWritable:true},
        {pubkey:toPubkey, isSigner:false, isWritable:true}
      ];
      let data = new Uint8Array(12);
      data[0]=2; data[1]=0; data[2]=0; data[3]=0; // transfer
      let l=lamports;
      for (let i=0;i<8;++i) { data[4+i]=l&0xff; l>>=8; }
      return {keys, programId: new PublicKey("11111111111111111111111111111111"), data};
    }
  };

  // --- TransactionInstruction ---
  function TransactionInstruction({keys, programId, data}) {
    this.keys = keys;
    this.programId = programId;
    this.data = data;
  }

  // --- Memo program ---
  // https://spl.solana.com/memo
  const MemoProgramId = new PublicKey("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr");

  // --- LAMPORTS_PER_SOL ---
  const LAMPORTS_PER_SOL = 1000000000;

  // --- Expose global object ---
  global.solanaWeb3 = {
    Connection,
    Transaction,
    TransactionInstruction,
    SystemProgram,
    PublicKey,
    clusterApiUrl,
    LAMPORTS_PER_SOL
  };
})(typeof window!=="undefined"?window:this);
