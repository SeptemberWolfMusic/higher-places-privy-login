/*!
 * Minimal Buffer polyfill for browser without require()
 * Supports Buffer.from(), Buffer.isBuffer()
 * Author: Adapted for browser use by ChatGPT
 * License: MIT
 */
(function (global) {
  if (global.Buffer) return;

  function Buffer(arg, encoding) {
    if (!(this instanceof Buffer)) return new Buffer(arg, encoding);
    if (typeof arg === 'number') {
      this.length = arg;
      this._arr = new Uint8Array(arg);
    } else if (typeof arg === 'string') {
      if (encoding === 'base64') {
        this._arr = base64ToBytes(arg);
      } else {
        this._arr = new TextEncoder().encode(arg);
      }
      this.length = this._arr.length;
    } else if (arg instanceof Uint8Array) {
      this._arr = arg;
      this.length = arg.length;
    } else {
      throw new TypeError('Invalid argument for Buffer');
    }
  }

  Buffer.prototype.toString = function (encoding = 'utf8') {
    if (encoding === 'base64') {
      return bytesToBase64(this._arr);
    }
    return new TextDecoder(encoding).decode(this._arr);
  };

  Buffer.from = function (input, encoding) {
    return new Buffer(input, encoding);
  };

  Buffer.isBuffer = function (b) {
    return b && b._arr instanceof Uint8Array;
  };

  // Added methods for compatibility
  Buffer.alloc = function (size) {
    return new Buffer(size);
  };
  Buffer.allocUnsafe = Buffer.alloc;

  Buffer.prototype.slice = function (start, end) {
    return new Buffer(this._arr.subarray(start, end));
  };

  // base64 encode/decode helpers
  function base64ToBytes(str) {
    const binary = atob(str);
    const len = binary.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      bytes[i] = binary.charCodeAt(i);
    }
    return bytes;
  }

  function bytesToBase64(bytes) {
    let binary = '';
    for (let i = 0; i < bytes.length; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
  }

  global.Buffer = Buffer;
})(typeof window !== 'undefined' ? window : this);
